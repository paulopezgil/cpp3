In the case that the unordered_map may be altered during the lifetime of our class's object, we can turn d_map into a reference to std::unordered_map<KeyT, ValT>, so whenever we modify the original unordered_map that was used to construct the class, d_map is also modified.

Now, notice that in our implementation, the overloaded sort for an empty paramenter list doesn't sort d_map, as the constructor already takes care of sorting it. However, if we decide to turn d_umap into a reference and decide to update the unordered_map that was used to construct UnorderedSort, then sort() will not return the map updated with the new data. One possible solution would be to reconstruct d_map with d_umap each time that sort function is called, which of course would be less efficient.